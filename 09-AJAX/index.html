<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
        XML简介：
            1.可扩展标记语言，被设计用来传输和储存数据
            2.与html类似，html中是预定义标签，XML都是自定义一些标签用来表示一些数据 
            3.AJAX曾经服务器返回的是XML对象
 
        AJAX简介：
            优点：
                1.可以在不刷新页面情况下，向服务器发送请求，实现与服务器端进行交互
                2.允许根据用户事件来更新部分页面内容
            缺点：
                1.没有浏览历史，不能退回
                2.存在跨域问题
                3.SEO不友好，数据由服务器端获取，再由js动态加载到页面上，网页源码上获取不到

        HTTP简介：
            定义：超文本传输协议，协议详细的规定了浏览器和万维网服务器之间互相通信的规则，主要规定了请求与相应

            请求报文：浏览器向服务器发送的请求
                格式与参数：
                    请求行：
                        请求类型：
                        url路径：
                        HTTP协议版本：
                    请求头：
                    空行：
                    请求体：

            响应报文：服务器向浏览器发送的结果
                格式与参数：
                    请求行：
                        HTTP协议版本：
                        响应状态码：
                        响应状态字符串
                    请求头：
                    空行：
                    请求体：

        下载Node.js：因为AJAX需要一个服务端,我们仿造一个服务器
            检测是否安装成功：cmd ——> node -v

        express框架：仿照服务器
            在外层终端输入：npm init --yes      初始化npm
            在外层终端输入：npm i express       安装express
            在express.js中引入框架
            在外层终端输入：node express.js     启动服务
            网页输入127.0.0.1:8000测试响应体

        nodemon：自动重启工具安装
            需要安装过node.js
            安装：npm install -g nodemon 
            启动：nodemon index.js   
        
        IE缓存问题
            描述：ie浏览器在ajax请求过一次后，会把服务器返回的结果储存在浏览器缓存中，再次请求会从浏览器获取，时效性过低
            解决：在请求行url路径中添加一个时间戳的参数，使每次url地址不同

        请求超时与网络异常处理
            xhr.timeout = 2000      2000毫秒后取消请求
            xhr.ontimeout = function(){}    请求超时回调函数
            xhr.onerror = function(){}      网络异常回调函数

        取消请求：
            xhr.abort()

        解决重复发送请求
            设置一个节流阀false，事件触发后判定一下，若果false则继续运行，如果true取消请求，开始一个新的请求
            判断之后修改为true，当xhr.readyState === 4时修改为false

        同源策略：
            网页与服务器的协议、域名、端口号必须完全相同，ajax默认这个要求，违背同源策略就是跨域

        jsonp解决跨域
            特点：只支持get请求
            工作原理：利用网页有跨域能力的标签发送请求，例如img、link、iframe、script

        cors解决跨域
            CORS，跨域资源共享，是官方的跨域解决方法，他的特点是不需要在客户端做任何特殊操作，完全在服务器中进行处理，
            支持get、post请求，跨域资源共享标准新增了一组FTTP首段字段，允许服务器声明那些网站通过浏览器有权限访问哪些资源

            工作原理：
                通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应后会对响应放行









     -->
</body>
</html>