<!-- 文档声明，html5语言 -->
<!DOCTYPE html>
<!-- 元素文字为英文，中文为cmn-hans -->
<html lang="en">
<!-- 文档头，不显示到页面中 -->
<head>
    <!-- 网页编码，汉字为GB2312，繁体字为GBK -->
    <meta charset="UTF-8">
    <!-- 使用IE浏览器时，使用edge浏览器内核 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- 适配移动端，禁止缩放 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 搜索引擎 -->
    <meta name="keywords" content="搜索引擎关键字">
    <!-- 作者信息 -->
    <meta name="author" content="作者信息">
    <!-- 网站信息 -->
    <meta name="author" content="网站信息">
    <!-- 网页图标 -->
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <!--  -->
    <link rel="stylesheet" href="./test1.css">
    <!-- 网页标题 -->
    <title>Document</title>
    <style>
        th,td{
            border: 1px solid red;
        }
    </style>
</head>
<body>
    <!-- html -->
    <div style="display: none;">
        <!-- 实体字符 -->
        <div>小于：&lt; 大于：&gt;  空格：&nbsp; 版权：&copy; and：&amp;</div>
        <!-- 文本元素 -->
        <h1>1级标题</h1>
        <h2>2级标题</h2>
        <h3>3级标题</h3>
        <h4>4级标题</h4>
        <h5>5级标题</h5>
        <h6>6级标题</h6>
        <p>段落</p>
        <span>span</span>
        <code><pre>white-space：pre；</pre></code>
        <!-- 超链接 -->
        <a href="https://www.bilibili.com/" target="_blank" title="BILIBILI">BILIBILI</a><br>
        <a href="javascript:alert('执行JS')">执行JS</a>
        <a href="mailto:123@qq.com">发邮件</a>
        <a href="tel:123">打电话</a><br>
        <a href="#anchor1" title="锚点链接">锚点1</a>
        <a href="#anchor2" title="锚点链接">锚点2</a>
        <a href="#anchor3" title="锚点链接">锚点3</a>
        <a href="#anchor4" title="锚点链接">锚点4</a>
        <h2 id="anchor1">锚点1</h2>
        <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Doloribus, ipsa.</p>
        <h2 id="anchor2">锚点2</h2>
        <p>Voluptatem temporibus quo dolorum debitis commodi similique facere veniam tempore?</p>
        <h2 id="anchor3">锚点3</h2>
        <p>Officia, repudiandae facere deserunt maxime ad ipsa quae voluptatem porro.</p>
        <h2 id="anchor4">锚点4</h2>
        <p>Tempore impedit quia ducimus nam ex animi suscipit nihil culpa.</p>
        <!-- 图片元素 -->
        <figure>
            <img style="width: 200px;height: 200px;"usemap="#b-map" 
            src="./../01-HTML基础/bilibili.jpg" alt="bilibili">
            <figcaption>
                <h2>图片区域标题</h2>
                <p>图片区域内容</p>
            </figcaption>
        </figure>
        <map name="b-map">
            <area shape="rect" coords="0,0,100,100" href="https://www.bilibili.com/" target="_blank" alt="">
        </map>
        <!-- 多媒体元素 -->
        <video controls loop muted autoplay>
            <source src="./../01-HTML基础/video.mp4">
            <source src="./../01-HTML基础/video.webm">
            <p>浏览器不支持video标签</p>
        </video>
        <audio controls loop muted autoplay>
            <source src="./../01-HTML基础/video.mp4" >
            <source src="./../01-HTML基础/video.webm" >
            <p>你的浏览器不支持audio标签</p>
        </audio>
        <!-- 列表元素 -->
        <ol type="1">
            <li>有序列表1</li>
            <li>有序列表2</li>
            <li>有序列表3</li>
        </ol>
        <ul>
            <li>无序列表1</li>
            <li>无序列表2</li>
            <li>无序列表3</li>
        </ul>
        <dl>
            <dt>标题1</dt>
            <dd>内容1</dd>
            <dt>标题2</dt>
            <dd>内容2</dd>
        </dl>
        <!-- 容器元素 -->
        <div>无语义</div>
        <header>头部元素</header>
        <article>文章主体</article>
        <nav>导航栏</nav>
        <section>章节</section>
        <aside>侧边栏</aside>
        <footer>底部元素</footer>
        <!-- 元素包含关系 -->
        <p>h5之前，行级元素不能包括块级元素，块级元素可以包含行级元素，a元素除外</p>
        <p>现在：h5中把元素分为流内容和措辞内容，包含关系由元素内容类别界定</p>
        <p>容器元素可以包含任何元素</p>
        <p>a元素几乎可以包含任何元素</p>
        <p>某些元素有固定的子元素</p>
        <p>h元素和p元素不能相互嵌套</p>
        <!-- 其他元素 -->
        <i>一段特殊的文字，斜体</i><br>
        <strong>重要不可忽略的内容，粗体</strong><br>
        <em>强调的内容，斜体</em><br>
        <del>错误的内容</del><br>
        <s>过期的内容</s><br>
        <abbr title="aa bb cc">缩写</abbr><br>
        <time datetime="2020-4-2">时间</time><br>
        <b>同等</b>的<b>重要</b><br>
        <q cite="">小段文本引用</q><br>
        <blockquote cite="">大段文本引用</blockquote><br>
        <!-- 框架页 -->
        <!-- <iframe src="https://www.bilibili.com/" frameborder="0"
        width="1280px" height="600px"></iframe> -->
        <!-- flash -->
        <object data="" type="">
            <param name="" value="">
            <embed src="" type="" quality="">
        </object>
        <!-- 表单 -->
        <form action="">
            <fieldset>
                <legend>输入框</legend>
                <input type="text" placeholder="文本框" ><p></p>
                <input type="password" placeholder="密码框" ><p></p>
                <input type="number" list="num-list" placeholder="数字框" ><p></p>
                <input type="search" placeholder="搜索框" ><p></p>
                <datalist id="num-list">
                    <option value="1">111</option>
                    <option value="2">222</option>
                    <option value="3">333</option>
                </datalist>
            </fieldset>
            <fieldset>
                <legend>复选框</legend>
                性别：
                <label><input type="radio" id="aa1" name="aa">男</label>
                <label><input type="radio" id="aa2" name="aa">女</label><p></p>
                爱好：
                <label><input type="checkbox" id="bb1" name="bb">香蕉</label>
                <label><input type="checkbox" id="bb2" name="bb">苹果</label>
                <label><input type="checkbox" id="bb3" name="bb">橘子</label>
            </fieldset>
            <fieldset>
                <legend>功能</legend>
                <input type="date" ><p></p>
                <input type="range" ><p></p>
                <input type="file" ><p></p>
                <input type="color" >
            </fieldset>
            <fieldset>
                <legend>按钮</legend>
                <input type="reset" value="重置按钮">
                <input type="button" value="普通按钮">
                <input type="submit" value="提交按钮"><p></p>
                <button type="reset">重置按钮</button>
                <button>普通按钮</button>
                <button type="submit">提交按钮</button>
            </fieldset>
            <fieldset>
                <legend>下拉菜单</legend>
                <select >
                    <option value="">123</option>
                    <option value="">123</option>
                    <option value="">123</option>
                </select>
            </fieldset>
            <fieldset>
                <legend>文本域</legend>
                <textarea  cols="30" rows="10"></textarea>
            </fieldset>
        </form>
        <!-- 表格元素 -->
        <table style="width: 100%; border-collapse: collapse; ">
            <caption>表格标题</caption>
            <thead>
                <tr>
                    <th>th</th>
                    <th>th</th>
                    <th>th</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td rowspan="2">td</td>
                    <td>td</td>
                    <td>td</td>
                </tr>
                <tr>
                    <td>td</td>
                    <td>td</td>
                </tr>
            </tbody>
            <tfoot>
                <tr>
                    <td colspan="3">td</td>
                </tr>
            </tfoot>
        </table>
    </div>

    <!-- css -->
    <div style="display: none;">
        <!-- 常用样式 -->
        <div style="color: red;">文字颜色</div>
        <div style="background-color: red;">背景颜色</div>
        <div style="font-size: 20px;">文字尺寸</div>
        <div style="font-weight: 700;">文字粗细</div>
        <div style="font-family: 'Courier New', Courier, monospace;">字体</div>
        <div style="font-style: initial;">字体样式</div>
        <div style="text-decoration: line-through;">文本修饰</div>
        <div style="text-indent: 2em;">首行缩进</div>
        <div style="line-height: 20px;">文本行高</div>
        <div style="width: 100px;height: 20px;">文本长宽</div>
        <div style="letter-spacing: 20px;">文本间隙</div>
        <div style="text-align: center;">水平排列方式</div>
        <p>背景图引用：background-image:url""</p>
        <p>背景图是否重叠：background-repeat:no-repeat</p>
        <p>背景图缩放：background-size:cover</p>
        <p>背景图位置：background-position:centent</p>
        <p>背景图定位：background-attachment:fixed</p>
        <div style="opacity: .5;">透明度</div>
        <div style="cursor: pointer;">鼠标样式</div>
        <div style="visibility: hidden;">隐藏盒子</div>
        <div style="display: list-item;">次盒子</div>
        <p>次盒子类别：list-style-type：disc</p>
        <p>次盒子位置：list-style-position：outside</p>
        <p>清除次盒子：list-style:none</p>
        <div style="text-align:justify;">行盒分散对齐</div>
        <div style="direction: ltr;">设置开始结束方向</div>
        <div style="writing-mode: vertical-lr;">设置文字书写方向</div>
        <!-- 选择器 -->
        <pre>
            类别：
            id选择器：#id{}
            元素选择器：元素名{}
            类选择器：.class{}
            通配符选择器：*{}
            属性选择器：[属性名]{}
            伪类选择器：:link、:visited、:hove、:active
            伪元素选择器：::before、::after
            组合:
            并且":"   后代" " 子元素">" 相邻"+" 后面"~" 多个","
            层叠:
            浏览器解决声明冲突的过程，自动处理
            1.比较重要性，！important是最重要的
            2.比较源次序
                千位：内联记为1，不是为0
                百位：选择器中所有id选择器数量
                十位：选择器中所有类选择器，伪类选择器，属性选择器数量
                个位：选择器中所有元素选择器，伪元素选择器数量
            3.比较源次序，书写靠后优先级高
        </pre>
        <!-- css属性值计算过程 -->
        <pre>
            一个元素从所有属性没有值到都有值的过程
            按照当前页面文档树形结构渲染
            1.没有冲突的声名作为css属性
            2.有冲突的声明按层叠规则确定css属性
            3.此时没有值的属性如果可以继承则继承
            4.此时没有值的属性使用默认值
        </pre>
        <!-- 盒子模型 -->
        <pre>
            display:inline 行盒 不换行
            display:block 块盒 独占一行
            display默认值为inline
            浏览器默认块盒：容器元素 h1-h6 p 
            浏览器迷人行盒：span a img video audio 
            内容盒：width、height
            填充盒：width、height、padding
            边框盒：width、height、padding、border
            整  体：width、height、padding、border、margin
            盒子模型：box-sizing:
            背景覆盖范围：background-clip:
            内容溢出：overflow:
            短词规则：word-break
            white-space：nowrap
            overflow：hidden
            text-overflow：ellipsis
            行盒特点：
                width、height：行盒沿着内容延伸，不能设置宽高
                padding：水平有效，垂直不会占据实际空间
                border：水平有效，垂直不会占用实际空间
                margin：水平有效，垂直方向不会占用实际空间
            行块盒特点：
                display：inline-block
                不独占一行，其他属性与块盒一致
                空白折叠发生在行盒，行块盒内部、之间
        </pre>
        <!-- 视觉格式化模型 -->
        <pre>
            常规流：
                所有元素默认情况下为常规流布局，块盒独占一行，行盒水平排列
                绝大部分元素包含块为父元素的内容盒，决定了盒子排列区域
                每个盒子总宽度必须为包含块的宽度
                width默认值为auto，将剩余空间吸收掉
                height默认值为auto，适应内容高度
                margin取值auto，左右平分，上下为零
                width吸收能力高于margin
                所有属性计算后还有剩余，会被margin-right吸收
                块盒水平居中，定宽，左右margin为auto
                属性可以取值百分比，相对于包含块尺寸
                常规流块盒会出现相邻外边距合并的问题，值为最大值
            浮动：
                float：left、right
                元素浮动时，元素必为块盒
                浮动元素包含块为父元素内容盒
                浮动盒子顶部不能高于上一个盒子顶部
                width、height为auto时意为适应内容尺寸
                margin为auto时表示0
                其他尺寸可以设置百分比，规则与常规流一致
                left靠上靠左，right靠上靠右
                浮动盒子在包含块排列时会避开常规流块盒
                常规流块盒排列时会无视浮动盒子
                行盒排列时会避开浮动盒子
                浮动盒子外边距不会发生合并
                如果文字没有在行盒中，浏览器会自动生成一个匿名行盒包裹文字
                高度坍塌，常规流块盒高度为自动时，计算高度不会考虑浮动盒子
                解决方法：在包含块最后添加一个元素，clear：both
            定位：
                position：static、realative、absolute、fixed
                只要position取值不是static，这个元素就是定位元素
                只要position取值不是static、realative，这个元素就会脱离文档流
                realative、absolute一定是块盒，一定不是浮动元素
                绝对定位和固定定位外边距不合并
                realative，left、right、top、bottom，相对原位置移动
                absolute，相对于上一级定位元素位置
                fixed，相对于视口
                居中：定宽高，四面属性为0，margin为auto
                堆叠：z-index数值越大越在上，只有定位元素有效
        </pre>
        <!-- 表单美化 -->
        <pre>
            :focus,元素聚焦时样式
            :checked，选框被选中时样式
            重置表单样式：
                input，textarea，button，select{border：none}
                input：focus{outline：none}
            resize：both，文本域是否可以调整大小
            自定义选框：
                label中放入radio，自定义元素，内容元素，label的for与radio的id关联
                修改自定义元素样式
                使用input：checked+修改自定义元素选中后样式
                隐藏radio元素
        </pre>
        <!-- @规则 -->
        <pre>
            @import“路径”，在css中引用样式重置表
            @chartset“UTF-8”，在css文件头行，字符编码集
            @font-face{
                font-family：“自定义字体名”
                src：url("字体文件地址")；
            }
        </pre>
        <!-- BFC -->
        <pre>
            块级格式化上下文，表示独立的渲染区域，规定该区域内常规流布局
            互不干扰，隔绝内外练习
            根元素，浮动元素，绝对定位元素，overflow不是visible的块盒
        </pre>
        <!-- 兼容 -->
        <pre>
            兼容问题：
                浏览器识别不出属性，或者解释与官方不同
            产生原因：
                1.浏览器为了市场份额不断更新，但官方更新较慢，浏览器自定义属性
                2.浏览器标准版本变化，浏览器不停更新，不同版本支持属性不同
            解决方法：
                厂商前缀：
                    IE：-ms-
                    chrome、safair：-webkit-
                    opera：-o-
                    Firefox：-moz-
                    产生原因：
                        1.市场竞争，标准没发布，浏览器提前使用，前缀表示非标准，但浏览器支持
                        2.标准在讨论中，浏览器提前使用
                    前缀插件：Autoprefixer，css文件->F1->Autoprefixer
                css hack:
                    根据IE浏览器不同版本设置不同css
                    *属性：兼容IE5\6\7
                    _属性：兼容IE5\6
                    属性值\9：兼容IE5~11
                    属性值\0：兼容IE8~11
                    属性值\9\0：兼容IE9\10
                    IE5\6\7外边距会翻倍
                    <!-- [if IE] > IE浏览器内核会显示 <![endif] -->
                    <!-- [if !IE] > 不是IE浏览器内核会显示 <![endif] -->
                    <!-- [if lt IE8] > IE8-浏览器内核会显示 <![endif] -->
            渐进增强：先适应大部分浏览器，然后针对新浏览器加入新的样式
            优雅降级：先制作完整功能，再针对低版本特殊处理
        </pre>
        <!-- 居中 -->
        <pre>
            行盒水平居中：父元素中：text-align:conter
            块盒水平居中：定宽，左右margin为auto
            绝对定位、固定定位：四面属性为0，margin：auto
            单行文本居中：line-height:height
            多行文本垂直居中，没有完美方法，可以设置上下内边距
        </pre>
        <!-- 扩展 -->
        <pre>
            浮动元素顶部不能高于上一个盒子顶部
            背景色\图：html没有设置时，body覆盖画布，，html设置了，body为边框盒
            字体单位：px固定像素、em先运算后继承、num先继承后运算
            元素对齐方式：vertical-align：
                ------------虚拟区顶部----------------
                ------------顶      线----------------
                ------------上  基  线----------------
                ------------基      线----------------
                ------------下  基  线----------------
                ------------地      线----------------
                ------------虚拟区底部----------------
                baseline：默认，元素基线与父元素基线对齐
                super：元素基线与父元素上基线对齐
                sub：元素基线与父元素下基线对齐
                text-top：元素虚拟区顶边与父元素顶线对齐
                text-bottom：元素虚拟区底边与父元素地线对齐
                top：元素虚拟区定编与line-box顶边对齐
                bottom：元素虚拟区底边与line-box底边对齐
                line-box行盒组成的每一行
                图片基线位置在图片下外边距
                表单元素基线位置在内容底边
                行块盒，行块盒内最后一行如果有line-box，基线为最后一行基线
                如果最后一行没有行盒，则使用行块盒下外边距作为基线
            堆叠上下文：
                stack context 规定区域内z轴排列顺序
                html元素 z-index定位元素
                1.创建堆叠上下文元素的边框盒背景
                2.z-index为负的堆叠上下文
                3.常规流非定位块盒
                4.浮动非定位盒子
                5.常规流非定位盒子
                6.z-index为0、auto的元素
                7.z-index为正的元素
                堆叠上下文互相独立，互不干扰
        </pre>
        <!-- svg -->
        <img src="./test1.svg" alt="">
    </div>

    <!-- html5 & css3 -->
    <div style="display: none;">
        <!-- 语义化标签 -->
        <header>页头</header>
        <nav>导航栏</nav>
        <main>主体</main>
        <article>整个页面</article>
        <section>章节</section>
        <aside>侧边栏</aside>
        <footer>页脚</footer>
        <!-- 多媒体 -->
        <video autoplay loop muted controls id="myvideo">
            <source src="./../01-HTML基础/video.mp4" type="video/mp4">
            <source src="./../01-HTML基础/video.webm" type="video/webm">
            <p>浏览器不支持</p>
        </video><br>
        <button class="btn1">视频时长</button>
        <button class="btn2">播放时间</button>
        <button class="btn3">切换静音</button>
        <button class="btn4down">-</button>音量
        <button class="btn4up">+</button>
        <button class="btn5">播放</button>
        <button class="btn6">暂停</button>
        <button class="btn7">从新加载</button><p></p>
        <script>
            var vdo = document.getElementById("myvideo")
            // 获取总时长
            var btn1 = document.querySelector(".btn1")
            btn1.addEventListener("click",function(){
                console.log("视频总时长为："+vdo.duration+"秒")
            })
            // 获取已播放时长
            var btn2 = document.querySelector(".btn2")
            btn2.addEventListener("click",function(){
                console.log("视频播放时间为："+vdo.currentTime+"秒")
            })
            // 切换静音
            var btn3 = document.querySelector(".btn3")
            btn3.addEventListener("click",function(){
                vdo.muted = !vdo.muted
                console.log("当前声音状态为："+vdo.muted)
            })
            // 音量
            var btn4down = document.querySelector(".btn4down")
            var btn4up = document.querySelector(".btn4up")
            btn4down.addEventListener("click",function(){ 
                if(vdo.volume <= 0.1){vdo.volume = 0}else{
                    vdo.volume-=0.1
                }
                console.log("当前音量为："+vdo.volume)
            })
            btn4up.addEventListener("click",function(){
                if(vdo.volume >= 0.9){vdo.volume = 1}else{
                    vdo.volume+=0.1
                }
                console.log("当前音量为："+vdo.volume)
            })
            // 播放：
            var btn5= document.querySelector(".btn5")
            btn5.addEventListener("click",function(){
                vdo.play()
                console.log("视频已播放")
            })
            // 暂停
            var btn6 = document.querySelector(".btn6")
            btn6.addEventListener("click",function(){
                vdo.pause()
                console.log("视频已暂停")
            })
            // 重新加载
            var btn7 = document.querySelector(".btn7")
            btn7.addEventListener("click",function(){
                vdo.load()
                console.log("视频已经重新加载")
            })
        </script>
        <!-- 新增表单 -->
        <input type="email"  placeholder="邮箱"><p></p>
        <input type="url"  placeholder="地址"><p></p>
        <input type="date"  placeholder="日期"><p></p>
        <input type="time" placeholder="时间"><p></p>
        <input type="month"  placeholder="月份"><p></p>
        <input type="week"  placeholder="周"><p></p>
        <input type="number"  placeholder="数字"><p></p>
        <input type="tel"  placeholder="手机号"><p></p>
        <input type="search"  placeholder="搜索"><p></p>
        <input type="color"  placeholder="颜色"><p></p>
        <pre>
            required表示内容不能为空
            placeholder表示提示内容
            autofocus表示页面加载完自动聚焦
            autocomplete表示显示之前输入过的内容
            multiple表示file表单可以多选
        </pre>
        <!-- 其他元素 -->
        <bdi>隔离元素</bdi><p></p>
        <datalist>
            <summary>展开提示</summary>
            <p>内容主题</p>
        </datalist><p></p>
        <dialog>自定义窗口</dialog><p></p>
        <mark>高亮文本</mark><p></p>
        标量：<meter min="0" low="50" high="70" max="100" value="60"></meter><p></p>
        进度条：<progress max="100" value="50"></progress><p></p>
        <!-- 新增选择器 -->
        <pre>
            div[属性名]：选中所有具有属性的元素
            k=v k^=v k$=v k*=v
            :first-child    :last-child     ：nth—child()
            :nth-of-type()
        </pre>
        <!-- 新增属性 -->
        <pre>
            尺寸计算：width:calc(100% - 30px)
            背景图引用：background-image：url("")
            背景图尺寸：background-size：width，height
            背景图定位：background-origin：content-box
            背景图剪切：background-clip：content-box
            圆角：border-radius:px
            图片模糊：filter：blur(5px)
            线性渐变：background-image：line-gradient(方向，color，color)
            重复线性渐变：。。。：repeating-linear-gradient(..)
            径向渐变：...：radial-gradient(中心点，颜色，颜色)
            重复径向渐变：。。。：reapting-radial-gradient(中心点，颜色，颜色)
            文字阴影：text-show：width height 距离 color
            盒子阴影：box-show：水平 垂直 距离 尺寸 颜色 内外
            文本溢出：text-overflow：ellipsis
            文本换行：word-break：break-all
            单词换行：word-wrap：break-word
            自定义字体：@font-face{font-family:自定义字体名;src：url(..)}
            盒子模型：box-sizing
            外形修饰：outline：宽度 样式 颜色
        </pre>
        <!-- 布局 -->
        <pre>
            流式布局：
                常用于移动web页面开发
                盒子宽度使用百分比
                通常会设置win-height来限制最大宽度
            flex弹性布局：
                通过给父元素添加display：flex属性来控制子元素排列方式
                主轴方向：flex-direction:row row-reverse column column-reverse
                主轴排列方式：justify-content：flex-start flex-end centent
                    space-around space-between
                主轴是否换行：flex-wrap：nowrap
                侧轴排列方式：align-items：stretch flex-start flex-end
                    content space-aroung space-between
                侧轴排列方式：align-content：
                子项felx：num,分配剩余空间
                子项align-self：侧轴排列方式
                子项order：num，前后位置，越小越靠前
            rem布局：
                1.选一套标准尺寸，一般宽度为750px
                2.屏幕宽度 除以 划分份数 得到html文字大小
                3.标准尺寸下所有尺寸除以html文字大小得到rem值
                4.不同标准 除以 固定的份数 得到 各自的html文字大小
                    再使用媒体称查询修改文字大小
                媒体查询：
                    @media scree and(nin-width:20px){css}
                还可以不使用媒体查询，可以引用flexible.js
                    此时默认html文字大小为标准宽度除以10
            响应式布局：
                利用媒体查询，在不同分辨率上设置不同样式
                手机：小于768px 设置为100%
                平板：768px ~ 992px 设置为750px
                桌面：992px ~ 1200px 设置为970px
                大屏：大于1200px 设置为1170px
            bootstarp栅格布局：
                下载并引用bootstarp相关文件
                使用预定义的类名控制布局
            vw vh：
                相对于视口尺寸的单位，百分比
        </pre>
        <!-- 过度与动画 -->
        <pre>
            trainsition：属性 花费时间 运动曲线 开始时间
                一般与：hover搭配使用
                过度属性：需要过度的css属性，全部可以写all，必写
                花费时间：单位s，必写
                运动曲线：默认ease，可不写
                开始时间：单位s，可不写
            自定义动画：
                @keyframes name{
                    0%{}，
                    100{}
                }
                使用方式：animation：动画名，持续时间，运动曲线，延迟时间，循环次数，是否反方向，结束状态
            2D转换：
                transform:translate(x,y)位置移动
                transform:rotate(num deg)旋转
                transform-origin:x,y 设置中心点
                transform：scale(x,y)缩放
            3D装换：
                transform:translate3d(x,y,z)    移动
                transform:rotate3d(x,y,z,deg)   旋转
                perspective：num px 透视
                transform-style:preserve-3d 开启子元素立体空间
        </pre>
        <!-- 私有前缀 -->
        <pre>
            火狐浏览器firefox：-moz-
            ie浏览器：-ms-
            谷歌chrome、苹果safari：-webkit-
            欧朋opera：-o-
        </pre>
        <!-- canvas画布元素 -->
        <pre>
            canvas标签 ie9+支持，默认宽300px 高150px 可通过标签width heiht修改
            canvas标签只是创建一个画布，具体操作需要通过js
            获取画布对象：画布对象.getContext("2d")
            只有矩形可以直接通过代码生成，其他需要通过路径生成
            画布对象.fillRect(x,y,w,h)  生成矩形填充框
            画布对象.strokeRect(x,y,w,h) 生成矩形边框
            画布对象.clearRect(x,y,w,h)  生成透明矩形
            画布对象.fillStyle = "颜色"   填充颜色
            画布对象.strokeStyle = "颜色"  边框颜色
            画布对象.linewidth = "num"     边框粗细，单位px
            画布对象.lineJoin = "样式"     线条结合处样式
            画布对象.moveTo(x,y)        路径起始点
            画布对象.lineTo(x,y)        下一个路径点
            画布对象.closePath()        闭和路径
            画布对象.fill()             自动闭和路径
            画布对象.stroke()           绘制边框
            画布对象.lineCap()          结合处样式
            画布对象.arc(x,y,r,star,end,boolean)    原型路径
            画布对象.arcTo(x1,y1,x2,y2,r)   曲线路径
            画布对象.translate(x,y).修改参考原点
            画布对象.rotate(deg*Math.PI/180)    角度旋转
            画布对象.scale(x,y) 缩放
        </pre>
    </div>
    
    <!-- js基础 -->
    <div style="display: none;">
    <pre>
        javascript：高级编程语言，客户端脚本语言，也已基于node.js在服务器运行
        脚本语言不需要编译，通过js解释器来解释运行
        用途：表单动态验证，网页特效，桌面程序，app，物联网，游戏开发
        js执行过程：浏览器有渲染引擎和js引擎组成，渲染引擎渲染html，css，js引擎解析js
        js引擎运行代码会将没一句js源代码转换为机器语言，再由计算机执行机器语言
        js组成：ES：js核心语法与知识，DOM：页面文档对象模型，BOM：浏览器对象模型
        js书写位置：行内，内嵌，外部
        js注释 // /**/
        js输出：alert(),console.log(),prompt()
        变量：程序在内存中申请一块用来存放数据的空间 var i = 1
        只声明不赋值：undefind，不声明不赋值：报错，不声明赋值，正常
        命名规范：
            由字母下划线美元符号数字组成
            区分大小写
            不能数字开头
            不能是关键字保留字
            变量名需要有意义，不能为a，b，c
            多个单词需要使用驼峰命名法
        数据类型：不同类型的数据占用空间不同，所有定义了数据类型
        数据类型是根据赋值的类型决定的，数据类型可以改变
        数字型number：
            数字前加0表示八进制，加0x表示16进制
            number.max_value表示数据类型最大值，超过使用Infinjty表示
            number.min-value表示数据类型最小值，小于使用-infinjty表示
            NaN表示非数字，isNaN(obj)可以判断对象是否为数据类型
        字符型string：
            使用单引号、双引号定义数据
            转义符号：\n换行，\\斜杠，\'单引号，\t缩进，\b空格
            使用 obj.length 获取字符串长度
            可以使用 + 进行字符串拼接
        布尔boolean：
            true表示真相当于1，false表示假相当于0
            与数字类型运算会得到数字类型
        无声明undefind：
            声明变量但是没赋值，会得到undefind，与数字运算得到NaN
        空null：
            声明变量为空，与数字运算得到数字类型
        数据检测：typeof obj
        数据类型转换：
            变成字符型：变量.toString(),String(变量)，加号拼接
            变成数字型：整数parseInt(数据)，浮点型parseFloat(数据)
                强制转换Number(数据)，隐式转换：使用-*/运算
            变成布尔型：Boolean(变量)，代表空否定的值会被转换成false
        运算符：
            算数运算符，+-*/%等，浮点型计算会出现精度问题
            递增递减运算符num++，num--，++num，--num
            比较运算符：>,>=,<,<=,==,===,!=,!===
            逻辑运算符：&&，||，！，
            赋值运算符：=，+=，-+，*=，/=，%=
        运算符优先级：
            1.小括号            ()
            2.一元运算符        ++ -- ！
            3.算数运算符        */% +-
            4.关系运算符        > >= < <=
            5.相等运算符        == ！= === ！===
            6.逻辑运算符        先&&后||
            7.赋值运算符        =
            8.逗号运算符        ，
        顺序结构，js是按顺序执行的
        分支结构：
            if(){}else if(){}else{}
            num > 0 ? num = 1 : num = 2
            switch(num){case 1:num=1 break;case 2:num=2 break;}
        循环结构：
            for(var i = 0,i < 10,i++){...}
            while(i < 0){... i++}
            do{... i++}while(i < 0)
            continue表示跳出此次循环
            break表示跳出此层循环
        数组:
            定义数组：
                var arr = new Array(length)
                var arr = [ , , ]
            遍历数组：
                for(var i = 0,i < arr.length,i++){
                    arr[i]
                }
            数组新增元素：
                arr.length修改数组长度
                arr[i]通过下标添加元素
            冒泡排序：
                通过双重for循环比较每个元素与后位所有元素
        函数：
            定义一个可以被重复利用的代码块
            声明：
                function fun(e){}
                var fun = function(e){}
            调用：fun(e)
            返回值：retuen放在函数体中，相当于fun() = return
            arguments:存放函数所有参数的伪数组
        作用域：
            定义：代码起作用的范围，减少命名冲突
            分类：
                es6之前分为全局作用域与局部作用域
                全局作用域：整个script标签或者js文件
                局部作用域：在函数内部
                全局变量：全局作用域中的变量
                局部变量：局部作用域中的变量
            作用域链：内部函数访问外部函数的变量通过作用域链查找
        预解析：
            js引擎运行js分为两步，预解析与代码执行
            预解析：js引擎会把所有var fun定义的变量函数提升到当前作用域最前面
                变量提升：提升所有变量声明到作用域最前面，不赋值
                函数提升：提升左右函数声明到作用域最前面，不调用函数
            代码执行：按照代码书写顺序从上往下执行
        对象：
            定义：属性与方法的集合
            创建对象：
                var obj = {
                    key:value
                    fun:function(){}
                }
                obj.key     obj.fun()
                
                var obj = new Object()
                obj.key = value
                obj.fun = function(){}
                obj.key obj.fun()

                function addfun(key){
                    this.key  = key
                    this.fun = function(){}
                }
                var obj = new addfun(key)
                obj.key obj.fun()
            遍历对象：
                for(var k in obj){
                    k 属性、方法名
                    obj[k] 属性值、方法体
                }
        内置对象：
            定义js自带的一些属性方法
            数学对象Math：
                圆周率：    math.pi
                最大值：    math.max()
                最小值:     math.min()
                绝对值：    math.abs()
                向下取整：  math.floor()
                向上取整：  math.ceil()
                四舍五入：  math.round()
                随机数：    math.random()
            日期对象Date：
                当前时间：  var date = new Date()
                年：        date.getFullYear()
                月-1：      date.getMonth()
                日：        date.getDate()
                星期：      date.getDay()
                时：        date.getHourse()
                分：        date.getMinutes()
                秒：        date.getsEconds()
                时间戳：    +new Date()
            数组Array：
                判断：arr instanceof Array Array.isarray(arr)
                添加元素：  
                    arr.push(a1)    末尾添加，返回数组长度
                    arr.unshift(a1) 起始添加 返回数组长度
                删除元素：
                    arr.pop()       删除最后一个元素，返回删除的元素
                    arr.shift()     删除第一个元素，返回删除的元素
                翻转数组：arr.reverse()
                冒泡排序：arr.sort(function(a,b){return a -b})
                获取索引：
                    arr.indexof(a)      顺序第一个满足的元素索引，没有返回-1
                    arr.lastindexof(a)  倒序第一个满足的元素索引，没有返回-1
                转换字符串：
                    arr.toString()      使用，将元素分卡
                    arr.join("分隔符")  使用分隔符将元素分卡
                数组拼接：arr1.concat(arr2) 返回新数组
                数组截取：
                    arr.slice(num,num)      
                    没有参数不会变化，一个参数表示到结尾，可以负值
                数组操作：
                    arr.splice(num1,num2,a)   删除或替换元素
                    num1为开始索引，num2为删除个数，a为添加的元素
            字符串String：
                字符串的不可变性，字符串的改变实际是改变储存地址
                获取索引：
                    str.indexof(a,num)  顺序查找返回索引，没有-1
                    str.lastIndexOf(啊，num)倒序查找
                获取字符：
                    str.charAt(index)   返回字符
                    str.charcodeat(index)   返回ascll码
                    str[index]          ascll码，ie8+
                截取：
                    str.substr(index1,indx2)    正常截取
                    str.slice(index,index)      不包括结束位置，可以负值
                    str.substring(i1,i2)        不包括结束位置，不能负值
                替换：str.replace("a","b")      替换第一个满足a为b
                转换数组：str.split("分隔符")
                大写：str.touppercase()
                小写：str.toLowercase()
        数据类型：
            简单数据类型
                由叫做基本数据类型和值类型
                储存变量储存的是值本身，
                例如string,bumber,boolean,undefind,null
            复杂数据类型
                又叫做引用类型
                储存变量储存的是地址
                通过new创建的对象都是复杂数据类型
            堆栈：
                简单数据类型存放在栈中
                复杂数据类型地址存放在栈中，指向堆中的值
            基本数据类型可以通过new创建成复杂数据类型
        DOM：
            定义：文档对象模型，分为文档，元素节点
            获取元素：
                document.getElementById("id")   返回元素对象
                document.getelementbytagname("标签")    返回元素伪数组
                document.getelementbuclassname("class") 返回元素伪数组
                document.queryselector("选择器")         获取元素
                document.queryselectorall("选择器")      获取元素伪数组
                element.getattribute("key")              获取属性值
                element.dataset.key                     获取data开头属性值
                document.body                           获取body   
                document.documentelement                获取html
            事件：
                可以被js侦查到的性行为
                click           鼠标左键点击
                mouseover       鼠标经过，冒泡
                mouseenter      鼠标经过，不冒泡
                mouseout        鼠标离开，冒泡
                mouseleave      鼠标离开，不冒泡
                mousedown       鼠标按下
                mouseup         鼠标抬起
                focus           获取焦点
                blue            失去焦点
            修改元素：
                div.innertext           非标准，不识别内部标签
                div.innerhtml           标准，识别内部标签
                div.属性                内置属性、表单属性
                div.setArrribute(k,v)   自定义属性
                div.removeattribute(k)  移出属性
                div.style.k             修改样式，行内添加
                div.classname           修改类名
            节点操作：
                nodetype节点类型，元素1，属性2，文本3
                div.parentnode          获取最近父级节点，没有null
                div.childnodes          获取所有子节点
                div.children            获取子元素
                div.firstchild          获取第一个子节点
                div.lastchild           获取最后一个子节点
                div.firstelementchild   获取第一个子元素
                div.lastelementchild    获取最后一个子元素
                div.nextsibling         获取下一个兄弟节点
                div.previoussibling     获取上一个兄弟节点
                div.nextelementsibling  获取下一个兄弟元素
                div.previouselementsibling 获取上一个兄弟元素
                document.ceraelement("tag") 创建元素
                div.appendchild(element)    插入元素
                div.insetnbefore(ele,ele)   指定位置插入
                div.removechild(ele)        删除元素
                ele.clonenode()             复制节点
            注册绑定事件：
                ele.addeventlistener("类型"，fun，冒泡)     ie9+
                ele.attachevent("类型"，fun，冒泡)          ie9-
            删除解绑事件：
                ele.类型 = null
                ele.removeeventlistener("类型"，fun)
            事件流：
                页面接收事件的顺序
                1.捕获阶段，从document一次向下查找事件源
                2.执行阶段，执行目标事件
                3.冒泡阶段，一次返回document
            事件对象：
                事件函数可以添加一个参数
                e = e || window.even
                e.target        获取触发事件元素
                e.type          获取事件类型
                e.clientx       返回鼠标视口x坐标
                e.clienty       返回鼠标视口y坐标
                e.pagex         返回鼠标页面文档x
                e.pagey         返回鼠标页面文档y
                e.screenx       返回鼠标电脑屏幕x
                e.screeny       返回鼠标电脑屏幕y
                e.keycode       按键ascll码
            键盘事件：
                keydown         键盘按下触发
                keyup           键盘松开触发
                keypress        松开触发，不识别功能键
        BOM:
            浏览器对象模型，核心为window，兼容型差
            window对象事件：
                window.onload   窗口全部加载完毕触发
                window.onresize 调整窗口大小触发
            定时器：
                settimeout(fun，num)    经过num毫秒运行fun函数
                cleartimeout(name)      清除定时器
                setinterval(fun,num)    时间间隔不断调用
                clearinterval(name)     清除定时器
            js执行队列：
                js为单线程，运行慢
                为了解决js运算慢的问题，根据CPU的计算能力，h5允许js创建多线程，实现同步异步
                同步任务，同步任务都在主线程执行
                异步任务分为普通事件，资源加载，定时器
                1.会把所有任务放到主线程执行，依次处理
                2.遇到同步任务执行，遇到异步任务转到异步进程处理
                3.如果异步任务被调用，则转到任务队列
                4.主线程执行完会看任务队列是否有任务，然后按顺序执行
            location
                提供一个获取、设置船体url的属性
                通信协议：//主机域名[:端口号]/路径/[?参数]#片段
                protocol：//hose[：port]/path/[?query]#fragment
                location.href       获取或设置整个url
                location.host       获取主机域名
                location.port       获取端口号，没有返回空字符串
                location.pathname   返回路径
                location.search     返回参数
                location.hash       返回片段
                location.assian()   跳转页面
                location.replace()  替换当前页面，不记录历史
                location.reload()   重新加载也没见，参数为true表示强制刷新
            navigator
                浏览器对象
                navigator.userAgent:    返回浏览器和计算机信息
            history
                浏览器历史记录对象
                history.forward()       前进
                history.back()          后退
                history.go(num)         正数前进，负数后退
        网页特效：
            offset元素偏移量：
                offset系列属性可以动态得到元素位置大小
                ele.offsetParent    得到带定位的父级元素，没有返回body 
                ele.offsettop       返回元素与定位父元素上方距离
                ele.offsetleft      返回元素与定位父元素左边距离
                ele.offsetwidth     返回自身边框盒宽度
                ele.offsetheight    返回自身边框盒高度
                offset可以得到任何样式表中样式值，style只能等到行内样式
                offset获取的值没有单位。style获取到的值有单位
                offset只读，style可写
            client可视区：
                client系列属性可以动态获取元素边框大小元素大小
                ele.clienttop       获取元素上边框宽度
                ele.clientleft      获取元素左边框宽度
                ele.clientwidth     获取元素填充盒宽度
                ele.clientwidth     获取元素填充盒高度
            scroll滚动：
                scroll可以获取元素大小，滚动距离
                ele.scrolltop       获取元素被卷去的上侧距离
                ele.scrollleft      获取元素被卷去的左侧距离
                ele.scrollwidth     获取自身实际宽度
                ele.scrollheight    获取自身实际宽度
                window.pageyoffset  获取页面被卷去上方距离
                window.pagexoffset  获取页面被卷去左侧距离
            动画原理：
                function name(obj,target){
                    clearinterval(obj.key)
                    obj.key = setinterval(function(){
                        if(){
                           clearinterval(obj.key) 
                        }
                        obj.style.属性 += 属性变化值
                    },num) 
                }
                调用函数
                匀速动画：盒子当前位置 += 固定值
                缓速动画：盒子当前位置+(目标值-现在位置)/10
                num：通常设置为15
            立即执行函数：
                (function(a,b){}){a,b}
                (function(a,b){}(a,b))
        移动端网页特效：
            touch触屏事件：
                touchstart      手指触摸一个元素时触发
                touchmove       手指在一个DOM元素上滑动时触发
                touchend        手指从一个DOM元素移开时触发
            触屏事件对象：
                e.touches       获取正在触摸屏幕所有手指列表
                e.targettouches 获取触摸当前DOM元素手指列表
                e.changedTouches 获取手指状态发生改变列表
                e.preventdefault()  阻止屏幕滚动
            classlist类名操作：
                ele.classlist.add("")       添加类
                ele.classlist.remove("")    移出类
                ele.classlist.toggle("")    切换类
            click事件300ms延迟：
                移动端会有双击事件，第一次点击后会有300ms延迟判断双击
                可以加视口标签 user-scalable=no 禁止缩放
        插件框架使用：
            下载引用文件，根据文档api修该参数
        本地储存：
            数据存储在用户浏览器中
            方便读取，刷新页面不丢失数据
            容量较大，sessionstorage可以放5M，localstorage可以20M
            只能储存字符串
            sessionStorage：
                生命周期为关闭页面
                同一页面下数据共享
                键值对形式储存
                sessionstorage.setitem(key,value)   储存
                sessionstorage.getitem(key)         获取
                sessionsterage.removeitem(key)      删除
                sessionstorage.clear()              清除
            localStorage：
                声明周期为关闭浏览器
                可以多窗口共享
                键值对形式储存
                localstorage.setitem(key,value)     储存
                localstorage.getitem(key)           获取
                localstorage.removeitem(key)        删除
                localstorage.clear()                清空
        JSON：
            js对象表示法
            特殊形式字符串，可以被任何语言识别，也可以转换成任意语言对象，用于数据交互
            json中属性与属性值必须都加双引号
            json -> js:     JSON.parse(JSON)    ie8+
                            eval("("+json+")")  ie8-
            js -> json:     JSON.stringify(JS)
    </pre>
    <script src="">
        // 变量互换
        var num1 = 1
        var num2 = 2
        var num3
        num3 = num1
        num1 = num2
        num2 = num3
        console.log("num1="+num1+";num2="+num2)
        // 转义字符：
        console.log("\\n表示换行，\\\表示斜杠，\\'表示单引号")
        // 字符串长度
        var str1 = "aabbcc"
        console.log("'"+str1+"'的长度为："+str1.length)
        // 字符串拼接
        var str2 = "aa"
        var str3 = "bb"
        console.log(str2+"+"+str3+"="+str2+str3) 
        // 数据类型
        var num4 = 0
        console.log(num4+"的数据类型为："+typeof num4)
        // 数据类型转换
        var num5 = 0
        console.log(typeof num5+"转换为"+typeof String(num5))
        // if分支
        var num6 = Math.random()
        if(num6<0.5){
            console.log(num6+"<0.5")
        }else{
            console.log(num6+">0.5")
        }
        // 三元表达式
        var num7 = Math.random()
        num7 < 0.5 ? console.log(num7+"<0.5") : console.log(num7+">0.5")
        // switch分支
        var num8 = Math.random()
        switch(num8 < 0.5){
            case true:
                console.log(num8+"<0.5")
                break;
            default:
                console.log(num8+">0.5")
        }
        // for循环
        var num9 = 0
        for(var i = 0;i <= 100;i++){
            num9 = num9 + i
        }
        console.log("0~100累加和为："+num9)
        // 多重for循环
        var str4 = ""
        for(var i = 1;i <= 9;i++){
            for(var j = 1;j<=i;j++){
                str4 = str4 + j + "*" + i + "=" + j*i +"\t"
            }
            str4 = str4 +"\n"
        }
        console.log(str4)
        // while循环
        var num10 = 0
        var num11 = 0
        while(num10 <= 100){
            num11 = num11 + num10
            num10++
        }
        console.log("0~100累加和为："+num11)
        // do while循环
        var num12 = 0
        var num13 = 0
        do{
            num13 = num13 + num12
            num12++
        }while(num12<=100)
        console.log("0~100累加和为："+num13)
        // 冒泡排序
        var arr1 = [3,0,5,2,1,4]
        console.log("顺序："+arr1.sort(function(a,b){return a-b}))
        console.log("逆序："+arr1.sort(function(a,b){return b-a}))
        // 函数参数
        function fun1(num1,num2){
            return num1 * num2
        }
        console.log("50*50="+fun1(50,50))
        // arguments
        function fun2(){
            return arguments[0] * arguments[1]
        }
        console.log("40*40="+fun2(40,40))
        // 创建对象
        function fun3(name,age){
            this.name = name 
            this.age = function(){
                return "年龄为"+age
            }
        }
        var obj1 = new fun3("小明",20)
        console.log(obj1.name + obj1.age())
        // 遍历对象
        var obj2 = {
            name:"小红",
            age:20
        }
        for(var k in obj2){
            console.log(k + ":" + obj2[k])
        }
        // 自定义范围随机数
        function fun4(min,max){
            return Math.floor(Math.random() * (max-min+1))+min
        }
        console.log(fun4(0,100))
        // 日期
        var date1 = new Date() 
        function fun5(date){
            var year = date.getFullYear()
            var month = date.getMonth() +1
            var dates = date.getDate()
            var week = date.getDay()
            var h = date.getHours()
            var m = date.getMinutes()
            var s = date.getSeconds()
            var arr = ["星期日","星期一","星期二","星期三","星期四","星期五","星期六"]                
            console.log("北京时间："+year+"年"+month+"月"+dates+"日"+arr[week]+h+":"+m+":"+s)
        }
        fun5(date1)
        // 倒计时
        function fun6(date){
            var alltime = +new Date(date)
            var newtime = +new Date()
            var times = (alltime - newtime)/1000
            var d = parseInt(times/60/60/24)
            var h = parseInt(times/60/60%24)
            var m = parseInt(times/60%60)
            var s = parseInt(times%60)
            s = s>9?s:"0"+s
            return d+"天"+h+":"+m+":"+s 
        }
        console.log("倒计时："+fun6("2023-5-5 24:0:0"))
        // 数组去重
        var arr2 = [1,1,2,2,3,3]
        var arr3 = new Array()
        for(var i = 0 ;i <= arr2.length;i++){
            if(arr3.indexOf(arr2[i]) == -1){
                arr3.push(arr2[i])
            }
        }
        console.log(arr3)
        // 字符查找
        var str5 = "abcdefg"
        console.log("d在'"+str5+"'中下标为"+str5.indexOf("d"))
    </script>
    <div style="position: relative;">
        <div class="div1" style="width: 100px;height: 100px;
        background-color: red; position: relative; "></div>
    </div>
    <script>
        var div1 = document.querySelector(".div1")
        div1.addEventListener("mousedown",function(e){
            var x = e.pageX - div1.offsetLeft
            var y = e.pageY - div1.offsetTop
            document.addEventListener("mousemove",move)
            function move(e){
                div1.style.left = e.pageX - x + "px"
                div1.style.top = e.pageY - y + "px"
            }
            document.addEventListener("mouseup",function(){
                document.removeEventListener("mousemove",move)
            })
        })
    </script>
    <div class="banner">
        <div class="img">
            <a href=""><img src="./../02-CSS基础/习题/定位练习/test.webp"></a>
            <a href=""><img src="./../02-CSS基础/习题/定位练习/test.webp"></a>
            <a href=""><img src="./../02-CSS基础/习题/定位练习/test.webp"></a>
        </div>
        <div class="switch">
            <div class="left">&lt;</div>
            <div class="right">&gt;</div>
        </div>
        <div class="foot">
            <div class="title">BILIBILI</div>
            <div class="spot"></div>
        </div>
    </div>
    <script>
        // 1.获取各个元素
        var banner = document.querySelector(".banner")
        var leftbtn = document.querySelector(".left")
        var rightbtn = document.querySelector(".right")
        var imgs = document.querySelector(".img")
        var spots = document.querySelector(".spot")
        // 2.鼠标经过显示左右按钮
        banner.addEventListener("mouseenter",function(){
            leftbtn.style.display = "block"
            rightbtn.style.display = "block"
            // 10.自动播放
            clearInterval(auto)
        })
        // 2.鼠标离开隐藏左右按钮
        banner.addEventListener("mouseleave",function(){
            leftbtn.style.display = "none"
            rightbtn.style.display = "none"
            // 10.自动播放
            auto = setInterval(function(){
                rightbtn.click()
            },2000)
        })
        // 3.动态获取图片数量并添加右下角圆圈
        for(var i = 0;i<imgs.children.length;i++){
            var a = document.createElement('a')
            spots.appendChild(a)
            // 8.圆圈点击事件
            a.setAttribute("index",i)
            a.addEventListener("click",function(){
                for(var i = 0;i < spots.children.length;i++){
                    spots.children[i].classList.remove("current")
                }
                this.classList.add("current")
                var index = this.getAttribute("index")
                num = index
                circle = index
                animate(imgs,-index*imgw)
            })
        }
        // 4.设置第一个圆圈选中样式
        spots.children[0].classList.add("current")
        // 4.复制第一张图到最后一张
        var firstimg = imgs.children[0].cloneNode(true)
        imgs.appendChild(firstimg)
        // 5.封装横向动画函数
        function animate(obj,target,callback){
            clearInterval(obj.timer)
            obj.timer = setInterval(function(){
                var step = (target - obj.offsetLeft)/10
                step = step>0?Math.ceil(step):Math.floor(step)
                obj.style.left = obj.offsetLeft+step+"px"
                if(obj.offsetLeft == target){
                    clearInterval(obj.timer)
                    if(callback){
                        callback()
                    }
                }
            },15)
        }
        // 6.左侧按钮点击事件
        var imgw = banner.offsetWidth
        var num = 0
        var circle = 0
        // 9.节流阀
        var flag = true
        leftbtn.addEventListener("click",function(){
        if(flag){
            flag = false
            if(num == 0){
                num = imgs.children.length-1
                imgs.style.left = -num*imgw + "px"
            }
            num--
            animate(imgs,-num*imgw,function(){flag = true})
            // 7.同步圆圈选中样式
            circle--
            if(circle < 0){
                circle = spots.children.length - 1
            }
            for(var i=0;i<spots.children.length;i++){
                spots.children[i].classList.remove("current")
            }
            spots.children[circle].classList.add("current")
        }
        })
        // 6.右侧按钮点击事件
        rightbtn.addEventListener("click",function(){
        // 9.节流阀
        if(flag){
            flag = false
            if(num == imgs.children.length-1){
                num = 0
                imgs.style.left = 0
            }
            num++
            animate(imgs,-num*imgw,function(){flag = true})
            // 7.同步圆圈选中样式
            circle++
            if(circle == spots.children.length){
                circle = 0
            }
            for(var i=0;i<spots.children.length;i++){
                spots.children[i].classList.remove("current")
            }
            spots.children[circle].classList.add("current")
        }
        })
        // 10.自动播放
        var auto = setInterval(function(){
            rightbtn.click()
        },2000)
    </script>
    </div>

    <!-- jquery -->
    <div style="display: none;">
    <pre>
        jq为js类库
        入口函数：$(function(){})   $(document).ready(function(){})
        $为顶级对象
        jq对象：
            使用js获取的为js对象，使用jq获取的为jq对象
            jq对象本质为利用$dui1DOM对象包装后产生的对象，一伪数组形式储存
            js对象与jq对象方法不通用
            js对象->jq对象      $("js")
            jq对象->js对象      $('jq')[index]  $("jq").get(index)
        jq隐私迭代：
            遍历DOM元素的过程叫隐式迭代
            给匹配到的所有元素进行遍历，执行相应方法，不需要我们再进行循环
        节流阀：设置一个flag，通过if判断程序是否可以继续运行
        选择器：
            $("选择器")
            $("li:first")               获取第一个li元素
            $("li:last")                获取最后一个li元素
            $("li:eq(index)")           获取索引号为index的li元素
            $("li:odd")                 获取奇数位li元素
            $("li:even")                获取偶数位li元素
            $("li").parent()            获取父级元素
            $("ul").children("li")      获取子代li元素
            $("ul").find("li")          获取后代
            $("li").siblings("li")      获取兄弟元素
            $("li").nextAll("li")       获取之后兄弟元素
            $("li").prevall("li")       获取之前兄弟元素
            $("li").hasclass("class")   判断当前元素是否有某类
            $("li").eq(index)           获取下标为index的li元素
        操作css：
            $("div").css("key")         获取css属性
            $("div").css("k","v")       设置css属性
            $("div").css({k1:"v1",..})  设置多个属性
        操作类名：
            $("div").addclass("n")      添加类名
            $("div").removeclass("n")   移出类名
            $("div").toggleclass("n")   切换类名
        动画：
            .show(time，运动曲线，fun)          显示动画
            .hide(time,运动曲线，fun)           隐藏动画
            .toggle(time,运动曲线，fun)         切换动画

            .slidedown(time,运动曲线，fun)      下滑显示
            .slideup(time,运动曲线，fun)        上滑隐藏
            .slidetoggle(time,运动曲线，fun)    切换

            .fadein(time,透明度，运动曲线，fun)         淡入
            .fadeup(time,透明度，运动曲线，fun)         淡出
            .fadetoggle(time,透明度，运动曲线，fun)     切换

            .animate({k:v},time,运动曲线，fun)
                没有参数表示没有动画，有参数时time与透明度必填
                动画时长：normal默认正常，slow慢，fast快，或者毫秒
                运动曲线：swing默认快-慢-快，linear匀速
                透明度：0~1
                回调函数，动画执行完毕调用
            动画排队：
                问题：同一对象快速执行多个动画会出现动画排队问题
                方法：在动画前加一个stop()方法，$("div").stop().show()
        属性操作：
            .prop("k")          获取固有属性，比如href、title等
            .prop("k","v")      设置固有属性

            .attr("k")          获取自定义属性
            .attr("k","v")      设置自定义属性

            data("k")           获取存储的数据
            data("k","v")       在元素上存储数据
        内容操作：
            .html()             获取元素内容
            .html("text")       修改元素内容
            
            .text()             获取文本信息
            .text("text")       修改文本信息

            .val()              获取表单value
            .val("value")       修改表单value
        元素操作：
            each(function(index,dom){})     遍历元素，index下标，dom元素
            $.each(obj,function(index,value){})     遍历对象
            var li = $('<li></li>>')        创建元素
            $("ul").append(li)              内部最后添加
            $("ul").prepend(li)             内部最前添加
            $("li").before(li)              外部前面添加
            $("li").after(li)               外部后面添加
            $("li").remove()                删除对象
            $("li").empty()                 删除对象所有节点
            $("li").html('')                清空对象内部
        尺寸操作：
            .width()    .height()           获取内容盒宽高
            .innerwidth()   .innerheight()  获取填充盒宽高
            .outerwidth()   .outerheight()  获取边框盒宽高
            .outerwidth(true)   .outerheight(true)  整体宽高
        位置操作：
            offset()        相当于页面文档位置，left，top可修改
            position()      相对于定位父级位置，left，top只读
            scolltop()      被卷去头部距离，可设置数字参数修改
            scollleft()     被卷去左侧距离，可修改
        事件：
            $("div").hover(fun1,fun2)   鼠标经过离开调用
            $("div").on({               事件绑定
                mouseenter:function(){},
                mousemove:function(){}
            })
            $("ul").on("click","li",function(){})   事件委托
            $("li").off()           解绑所有事件
            $("li").off("click")    解绑单个事件
            $("ul").off("click"."li")   解除事件委托
            $("div").one("click",fun)   只执行一次
            $("input").focus(fun)       表单获取焦点时调用
            $("input").change(fun)      表单失去焦点调用
            $("input").trigger("docus") 表单执行指定事件调用，触发默认事件
            $("input"),tirggerhandler("focus")      不会触发默认事件
            e.preventDefault()      阻止默认行为
            e.stoppropagetion()     阻止冒泡
        拷贝对象：
            $extend(boolean,obj,obj1,obj2)
            把obj1、obj2拷贝给obj
            boolean：true表示深拷贝，false表示浅拷贝
            深拷贝：数据完全拷贝，属性会合并在一起没修改obj1不影响obj
            浅拷贝：简单数据完全拷贝，复杂数据拷贝地址，修改obj1影响obj
        jq多库共存：
            问题：jq使用$作为标识符，如果其他js库也使用$作为标识符，会冲突
            方法：不使用$,直接使用jquery，比如jquery("div")
                修改标识符：var 标识符 = $.noconflict()
        jq插件：
            jq插件库，jq之家
            使用方法：
                下载插件，解压插件，拷贝引用相关文件
                复制html，css，js
                通过文档修改相关内容
    </pre>
    </div>

    <!-- js高级 -->
    <div style="display: none;">
    <pre>
        原型链：
            每个函数都有一个prototype属性           显示原型
            指向一个空的object对象                  原型对象

            每个原型对象都有一个constructor属性指向构造函数
            给原型对象添加属性或方法，函数所有实例都会自动拥有方法和属性
                原型对象.prototype.自定义方法名 = function(){}

            每个实例对象都有一个__proto__属性       隐式原型
            实例对象隐式原型值 = 构造函数显示原型的值

            访问一个对象属性时：
                1.先在自身属性中查找，找到返回
                2.沿着隐式原型链查找，找到返回
                3.最终没找到，返回undefind
            
            所有函数都是function的实例，包括它自己
            object函数的原型对象null是原型链的尽头

            读取对象属性时，会自动到原型链中查找，
            设置对象属性时，不会设置到原型链中，会直接给当前对象赋值覆盖
            方法一般会定义在原型中，属性一般会通过构造函数定义在对象本身

            obj instanceof fun：判断obj是不是fun的实例对象
            如果fun的显示原型在obj的隐式原型链上，则返回true

        执行上下文：
            代码分为全局区代码，函数代码
            全局代码上下文：
                执行代码前将window作为全局执行上下文
                对全局数据进行预处理
                    var定义的全局变量赋值为undefind，添加为window的属性
                    dunction定义的全局函数添加为window的方法
                    this赋值为window
                开始执行代码
            函数代码执行上下文：
                调用函数执行函数体之前，创建对应的函数执行上下文
                对函数代码进行性预处理
                    形参变实参，添加为上下文属性
                    argument赋值为参数列表，添加为上下文属性
                    var定义的局部变量赋值为undefind添加为上下文属性
                    function定义函数添加为上下文方法
                    this赋值为调用函数的对象
                开始执行代码
            执行上下文栈
                全局代码执行前，js会创建一个栈来储存管理所有执行上下文
                全局执行上下文确定后，添加到栈中
                调用函数时，创建函数执行上下文，添加到栈栈中
                当前函数执行完从栈中移除，当前执行函数永远是最上层
                所有代码执行完只剩下window
        作用域：
            定义：表示一个代码生效的区域
            作用域是静态的，编写代码时就确认了
            作用域分为全局作用域，局部作用域，块级作用域
            作用域起到隔离变量的作用，避免命名冲突
            作用域链表示多个作用域形成的链，它的方向是从内到外的
            查找变量会沿着作用域链查找
        闭包：
            当一个嵌套的内部函数引用了嵌套的外部函数的变量时会产生闭包
            闭包存在于嵌套的内部函数中
            绝大部分人认为闭包就是嵌套的内部函数
            极少数人认为闭包是包含被引用变量的对象
            常见闭包：
                将一个函数作为另一个函数的返回值
                将函数形参作为实参传递给另一个函数
            闭包作用：
                函数内部变量在函数执行外后依然存活，延长局部变量的生命周期
                使函数外部可以操作到函数内部的数据
            闭包生命周期：
                产生：在嵌套内部函数定义执行完时产生，注意函数提升
                死亡：在嵌套内部函数成为垃圾对象时死亡，手动定义null
            闭包应用模块化：
                具有特定功能的js文件
                将所有数据和功能都封装在一个函数内部
                只向外暴露多个方法和对象
                通过模块暴露的对象调用方法属性来实现对应功能
            闭包缺点：
                函数执行完后，闭包一直存在，占用内存时间长
                过度占用内存，容易内存泄漏
                解决：能不用闭包就不用，使用后及时销毁
            内存溢出：
                程序运行需要的内存超过剩余内存时会抛出内存溢出错误
            内存泄漏：
                占用内存没有及时释放，内存泄漏积累多了会导致内存溢出
                常见内存泄漏：
                    意外的局部变量，定义局部变量没有使用var 
                    没有及时清理计时器或者回调函数
                    闭包
        对象创建模式：
            object构造函数创建
                方法：使用 new object创建对象
                适用：起始对象内部数据是不确定的
                问题：语句过多
            字面量创建：
                方法：使用{}创建对象
                适用：起始对象内部数据是确定的
                问题：创建多个对象会有重复代码
            工厂模式创建：
                方法：通过工厂函数创建对象并返回
                适用：需要创建多个对象
                问题：对象没有具体类型都是object类型
            自定义构造函数：
                方法：自定义构造函数，通过new创建对象
                适用：创建多个类型确定的对象
                问题：每个对象都有相同的数据，浪费内存
            自定义+显示原型：
                方法：自定义构造函数，属性在函数中初始化，方法添加到原型中
        原型链继承：
            方法：
                1.定义父类型构造函数
                2.给父类型原型添加方法
                3.定义子类型构造函数
                4.子类型原型 指向 父类型实例对象
                5.给子类型原型添加方法
                6.创建子类型的实例对象
            属性：
                在子类型构造函数中使用call()借用父类型构造函数初始化相同属性
        进程与线程：
            进程：程序的一次执行，占有一片独立的空间，可以通过window任务管理器查看
            线程：进程内一个独立的执行单元，是程序执行的一个完整流程，cpu最小调度单元
            应用程序必须运行在某个进程的某个线程上
            一个进程至少有一个运行的线程，主线程，进程启动后自动创建
            多线程：一个进程可以同时运行多个线程
            一个进程中数据可以供其中多个线程共享
            多个进程之间数据不能共享
            线程池：保存多个对象的容器，实现线程对象反复利用
            浏览器是多线程的，fire和老版ie是单线程，谷歌和新版ie是多线程
            浏览器内核，支持浏览器运行的最核心的程序，有很多模块组成
            主线程内容：
                js引擎模块：负责js程序的编译与运行
                html，css文档解析模块：负责页面文本解析
                DOM，css模块：负责DOM。css在内存中相关处理
                布局与渲染模块：负责页面布局和绘制效果
            分线程内容：
                定时器模块：负责定时器的管理
                DOM事件响应模块：负责事件的管理
                网络请求模块：负责ajax请求
                
            定时器不能保证真正定时执行，一般会延迟一点，也有可能延迟很长时间

            js是单线程的但是h5中web workers可以多线程运行
            settimeout()回调函数是在主线程执行的
            定时器回调函数只有在运行栈所有代码执行完后才会执行
            js作为脚本语言主要用途是与用户互动及操作DOM，所以只能单线程，否则会有复杂同步问题
            代码分为初始化代码和回调代码
            
            js引擎执行代码基本流程：
                先执行初始化代码，比如设置定时器，绑定监听作用，ajax请求
                最后某个时刻才会执行回调函数
            
            模型两个重要组成部分：
                事件管理模块：定时器，DOM事件，ajax
                回调函数
            
            模型运转流程：
                初始化代码，将回调函数交给对应模块管理
                事件发生时，管理模块会将回调函数及其数据添加到回调函数中
                初始化代码执行完后，才会遍历读取回调队列中的回调函数执行
            
            web workers：
                将一些大量计算的代码交个web workers运行，从而不冻结用户界面
                子线程完全受主线程控制，而且不能操作dom，比如aleart

                设置分线程js文件
                在主线程js中发送数据到分线程js文件
                分线程js文件接受处理返回数据
                主线程js接受数据

                缺点：慢
                不能跨域加载js
                web workers内代码不能访问DOM，不能更新界面
                不是每个浏览器都支持
    </pre>
    <script src="">
    // 创建对象模式
        // object创建对象
        var p1 = new Object()
        p1.name = "p1"
        p1.setage = function(age){
           this.age = age
        }
        // 字面量创建
        var p2 = {
            name:"p2",
            setage:function(age){
                this.age = age
            }
        }
        // 工厂模式创建对象
        function addp3(name){
            var p = {
                name:name,
                setage:function(age){
                    this.age = age
                }
            }
            return p
        }
        var p3 = new addp3("p3")
        // 自定义构造函数模式
        function addp4(name){
            this.name = name
            this.aetage = function(age){
                this.age = age
            }
        }
        var p4 = new addp4("p4")
        // 自定义构造函数 + 显示原型
        function addp5(name){
            this.name = name
        }
        addp5.prototype.setage = function(age){
            this.age = age
        };
    // 自定义模块
        (function(window){
            var name = "name"
            function setage(age){
                console.log("年龄为"+age)
            }
            window.getmessage = {
                name:name,
                setage:setage
            }
        })(window)
        console.log("年龄为"+getmessage.name)
        getmessage.setage(1)
    // 原型链继承
        // 创建父类构造函数
        function fu(name){
            this.name = name
        }
        // 给父类构造函数添加方法
        fu.prototype.setname = function(name){
            this.name = name
        }
        // 创建子类构造函数，并使用call调用父类构造方法
        function zi(name,age){
            fu.call(this,name)
            this.age = age
        }
        // 子类原型 指向 父类实例对象
        zi.prototype = new fu()
        // 子类原型对象的constructor指向子类
        zi.prototype.constructor = zi
        // 子类添加方法
        zi.prototype.setage = function(age){
            this.age = age
        }
        // 创建子类实例对象
        var zi1 = new zi("zi",1)
        console.log(zi1.name,zi1.age)
        // 子类实例对象使用父类方法
        zi1.setname("newzi")
        zi1.setage(2)
        console.log(zi1.name,zi1.age)
    // web workers
        var worker = new Worker("./../06-JS高级/workers.js")
        worker.postMessage(10)
        worker.onmessage = function(e){
            console.log(e.data)
        }
    </script>
    </div>

    <!-- less基础 -->
    <div style="display: none;">
    <pre>
        在html中使用less需要引入less.js文件
        下载easy less保存后可直接生成css文件

        less是一种动态样式语言，属于css预处理器
        扩展css增加了变量，参数，函数等，使css更容易维护扩展
        less既可以在客户端上运行，也可以借助node.js在服务端运行

        less变量：
            定义：@变量名：变量值
            使用：
                属性名：@{变量名}
                属性值：@变量名
                url：@{url}
            作用域：变量会延迟加载，谁近用谁
            运算：可以使用+-*/运算，运算符前后空格，单位要统一
            避免编译：~"calc(...)"

        less嵌套：
            按照DOM层级一层一层嵌套
            伪类与伪元素选择器需要在前面加&
            .class{
                css
                &:hover{css}
                .class{}
            }

        less混合：
            混合：将一系列属性从一个规范引到另一个规范中
            普通混合：
                .class{css}
                .div{.class()}
            混合部分不编译：
                .class(){css}
                .div{.class}
            带参数混合：
                .class(@w,@h){css}
                .div{.class(20px,20px)}
            默认参数混合：
                .class(@w:10px){css}
                .div{.class()}
            匹配模式：
                .all(@_,@_){css}
                .all(class1,@w){css}
                .all(class2,@w){css}
                .div{.all(class1,10px)}
            
        less方法：
            arguments：
                使用：@arguments
                .class(...){border:@arguments}
                .div{.class(1px,solod,red)}
            when and:
                .class(@w) when (...) and (...){css}
                .div{.class(10px)}
            when not:
                .class(@w) when not (...){css}
                .div{.class(10px)}
            when ,:
                .class(@w) when (...) , (...){css}
                .div{.class(10px)}
            递归循环：
                .class(@n,@i:1) when(@i < @n){
                    .div@{i}{css}
                    .class(@n.(@i+1))
                }
                .class(10)
            属性拼接：
                .class(){css}
                .div{
                    .class();
                    属性+：属性值；
                    属性+_:属性值
                }
        
        less继承：
            将多个重复样式提取出来,不能有参数
            .class{css}
            .class:hover{css}
            .div1{&:extend(.class all)}
            .div2{$:extend(.class all)}
        
        less文件导入：
            普通导入：
                @import "./xxx.less"
            导入不编译：
                @import(reference) "..."
            相同文件只导入一次：
                @import(once) "..."
            导入多次相同文件：
                @import(multiple) "..."
        
        less函数：
            less中封装了很多函数库，例如颜色定义，操作，混合等
    </pre>
    </div>

    <!-- bootstrap基础 -->
    <div>
    <pre>
        前端框架用于构建响应式移动设备优先的前端框架
        bootstrap5不支持ie
        如果引入了jq，那么监听bootstrap的事件必须使用jq的方法

        下载并引用bootstrap文件，css放在最前，js放在最后

        布局：

         
        


    </pre>
    </div>



</body>
</html>

