<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS高级</title>
</head>
<body>
    <!-- 原型链 -->
    <!-- 
        每个函数都有一个prototype属性(显示原型)，它指向一个空的Object实例对象(原型对象)  
        每个原型对象都有一个constructor属性，它指向构造函数
        给原型对象添加属性或者方法，函数的所有实例会自动拥有原型中的属性或者方法 
            原型对象.prototype.自定义方法名 = function(){...}

        每个实例对象都有一个__proto__属性(隐式原型)
        实例对象的隐式原型的值 等于 其构造函数的显示原型的值 

        当访问一个对象属性时，
        1.先在自身属性中查找，找到返回
        2.如果没有，沿着__proto__这条链向上查找，找到返回
        3.如果最终没找到，返回undefind
        由于沿着__proto__寻找，又称为隐式原型链

        所有函数都是Function的实例，包括它自己
        Object的原型对象(null)是原型链的尽头

        读取对象属性值时，会自动到原型链中查找，
        设置对象属性值时，不会设置到原型链中，会直接给当前对象赋值或覆盖
        方法一般定义在原型中，属性一般会通过构造函数定义在对象本身上

        A instanceof B:判断左边的实例对象A是不是右边构造函数B的实例
        如果B函数的显示原型在A对象的原型链上，返回true   
     -->

    <!-- 执行上下文 -->
    <!-- 
        变量声明提升:声明过得变量在声明语句之前就可以访问到,值为undefind
        函数声明提升:声明过得函数在声明语句之前就可以直接调用

        执行上下文
        代码根据位置分为全局代码和函数代码
        全局代码执行上下文:
            执行代码前将window确定为全局执行上下文
            对局部数据进行预处理
                var定义的全局变量赋值为undefind，添加为window的属性
                function定义的全局函数添加为window的方法
                this赋值成window
            开始执行全局代码
        局部代码执行上下文
            调用函数执行函数体之前，创建对应的函数执行上下文（虚拟）
            执行代码前进行预处理
                形参变量赋值成实参，添加为执行上下文的属性
                arguments赋值成参数列表，添加为执行上下文的属性
                var定义的局部变量赋值为undefind，添加为执行上下文的属性
                function定义的全局函数添加为执行上下文的方法
                this赋值成调用函数的对象
            开始执行函数体代码

        执行上下文栈
            全局代码执行前，JS引擎会创建一个栈来储存管理所有的执行上下文
            全局执行上下文(window)确定后，添加到栈中
            调用函数时，创建函数执行上下文，添加到栈中
            当前函数执行完后，从栈中移出，当前执行的函数永远是栈最上面那层
            所有代码执行完后，栈中只剩下window
     -->

    <!-- 作用域 -->
    <!-- 
        作用域相当于一块底盘，表示一个代码所在得区域
        作用域是静态的，编写代码时就确定了
        作用域分为全局作用域、函数作用域、块作用域(ES6+)
        作用域起到隔离变量的作用，不同作用域下同变量名不会冲突

        作用域链表示多个作用域形成的链，它的方向是从内到外的
        查找变量时沿着作用域链查找的
     -->

    <!-- 闭包 -->
    <!-- 
        当一个嵌套的内部函数引用了嵌套的外部函数的变量时，就产生了闭包
        闭包存在于嵌套的内部函数中
        绝大部分人认为闭包就是嵌套的内部函数
        极少数人认为闭包是包含被引用变量的对象
        
        常见的闭包：
            1.将一个函数做为另一个函数的返回值
            2.将函数形参作为实参传递给另一个函数调用    
            
        闭包作用：
            1.使函数内部变量在函数执行完后，依然存活在内存中，延长了局部变量的生命周期
            2.使函数外部可以操作到函数内部的数据

        闭包生命周期：
            1.产生：在嵌套内部函数定义执行完时产生，注意函数提升
            2.死亡：在嵌套的内部函数成为垃圾对象时，手动定义为null 

        闭包应用
            1.自定义模块化
                具有特定功能的js文件
                将所有数据和功能都封装在一个函数内部
                只向外暴露多个方法或对象
                通过模块暴露的对象调用方法来实现对应的功能
            
        闭包缺点
            1.函数执行完后，闭包一直存在，函数内的局部变量没有释放，占用内存时间边长
            2.容易造成内存泄漏
            解决方法1：能不用闭包就不用闭包
            解决方法2：及时释放闭包，让内部函数成为垃圾对象

        内存溢出：
            一种程序运行出现的错误
            当程序运行所需要的内存超过了剩余的内存时，就会抛出内存溢出的错误

        内存泄漏：
            占用的内存没有及时释放
            内存泄漏积累多了就容易导致内存溢出
            常见的内存泄漏：
                1.意外的全局变量，定义局部变量时没有使用var
                2.没有及时清理的计时器或者回调函数
                3.闭包
     -->

    <!-- 对象创建模式 -->
    <!-- 
        Object构造函数创建对象
            创建方法：先创建Object对象，再动态添加属性方法
            适用场景：起始不确定对象内部数据
            问题：语句过多

        字面量创建对象
            创建方法：使用{}创建对象，同时指定属性方法
            适用场景：起始时对象内部数据是确定的
            问题：创建多个对象会有重复代码

        工厂模式创建对象
            创建方法：通过工厂函数动态创建对象并返回
            适用场景：需要创建多个对象
            问题：对象没有具体类型，都是Object类型

        自定义构造函数创建对象
            创建方法：自定义构造函数，通过new创建对象
            适用场景：需要创建多个类型确定的对象
            问题：每个对象有相同的数据，浪费内存

        自定义构造函数 + 显示原型 创建对象
            创建方法：自定义构造函数，属性在函数中初始化，方法添加到原型中
            适用场景：需要创建多个类型确定的对象
     -->

    <!-- 原型链继承 -->
    <!-- 
        原型链继承方法：
            1.定义父类型构造函数
            2.给父类型的原型添加方法
            3.定义子类型构造函数
            4.子类型的原型 = 父类型的实例对象
            5.让子类型原型的constructor属性指向子类型构造函数，否则会指向父类型构造函数
            5.给子类型的原型添加方法
            6.创建子类型的实例对象，此时可以调用父类型的方法
        关键：子类型的原型 是 父类型的一个实例对象

        构造函数继承方法（假的，实际为简化代码）：
            1.定义父类型构造函数
            2.定义子类型构造函数
            3.在子类型构造函数中调用父类型构造
        关键：在子类型构造函数中通过call()调用父类型构造函数

        组合继承方法：
            1.利用原型链实现对父类型对象方法的继承
            2.利用call()借用父类型构造函数初始化相同属性
     -->

    <!-- 进程与线程 -->
    <!-- 
        进程：程序的一次执行，占有一片独立的空间，可以通过windows任务管理器查看
        线程：进程内一个独立的执行单元，是程序执行的一个完整流程，是cpu的最小调度单元

        应用程序必须运行在某个进程的某个线程上
        一个进程中至少有一个运行的线程：主线程，进程启动后自动创建
        一个进程可以同时运行多个线程，这个进程是多线程的
        一个进程内的数据可以供其中多个线程直接共享
        多个进程之间的数据不能共享
        线程池(thread poo):保存多个线程对象的容器，实现线程对象的反复利用
        浏览器都是多线程的，fire和老版IE是单进程，chrome和新版IE是多进程

        浏览器内核：支撑浏览器运行的最核心的程序，由很多模块组成
        主线程：
            js引擎模块：负责js程序的编译与运行
            html，css文档解析模块：负责页面文本的解析
            DOM/CSS模块：负责dom/css在内存中的相关处理
            布局与渲染模块：负责页面布局和效果的绘制（内存中的对象）
        分线程：
            定时器模块：负责定时器的管理
            DOM事件响应模块：负责事件的管理
            网络请求模块：负责ajax请求

        定时器不能保证真正的定时执行，一般会延迟一点，也有可能延迟很长时间

        js是单线程的，但是H5中的Web Workers可以多线程运行
        setTimeout()的回调函数是在主线程执行的
        定时器回调函数只有在运行栈中所有代码执行完后才会执行
        js作为脚本语言主要用途是与用户互动以及操作DOM，所以只能是单线程，否则会带来很复杂的同步问题
        代码分为初始化代码和回调代码
        js引擎执行代码基本流程：
            先执行初始化代码，包含一些特别的代码，比如设置定时器，绑定监听事件，发送ajax请求
            最后在某个时刻才会执行回调函数

        模型的两个重要组成部分
            事件(定时器、DOM事件、Ajax)管理模块
            回调队列
        模型运转流程：
            初始化代码，将回调函数交给对应模块管理
            当事件发生时，管理模块会将回调函数及其数据添加到回调函数中
            只有当初始化代码执行完后，才会遍历读取回调队列中的回调函数执行

        H5规范实现js分线程 Web Workers
            可以将一些大量计算的代码交给web Worker运行从而不冻结用户界面
            子线程完全受主线程控制，而且不能操作DOM，比如alert

            设置分线程执行的js文件
            在主线程js中发送数据到分线程js文件
            分线程js文件接受、处理、返回数据
            主线程js接收数据

            缺点：慢
            不能跨域加载js
            worker内代码不能访问DOM，不能更新界面
            不是没个浏览器都支持这个新特性
     -->

     

    <!-- 闭包练习 -->
    <!-- <script >        
        function fun(n,o){  
            console.log(o)
            return{
                fun:function(m){
                    return fun(m,n)
                }
            }
        }

        var a = fun(0)          //n:0           o:undefind
        a.fun(1)                //m:1   n:0     o:0
        a.fun(2)                //m:2   n:0     o:0
        a.fun(3)                //m:3   n:0     o:0

        var b = fun(0).fun(1).fun(2).fun(3)
        // n:0                  o:undefind  
        // m:1  n:0     n:1     o:0
        // m:2  n:1     n:2     o:1
        // m:3  n:2     n:3     o:2  

        var c = fun(0).fun(1)   
        // n:0                  o:undefind  
        // m:1  n:0     n:1     o:0
        c.fun(2)
        // m:2  n:1     n:2     o:1
        c.fun(3)
        // m:3  n:1     n:3     o:1

    </script> -->

    <!-- web workers主线程 -->
    <!-- <p>斐波那契数列，f(0)=0,f(1)=1,f(n)=f(n-1)+f(n-2)</p>
    <input type="text" name="" id="" placeholder="输入数字">
    <button>运算</button>
    <script>
        var input = document.querySelector("input") 
        var btn = document.querySelector("button")
        btn.onclick = function(){
            var num = input.value
            // 创建一个Worker对象
            var worker = new Worker("./workers.js")
            // 向分线程发送数据
            worker.postMessage(num)
            // 接受分线程数据
            worker.onmessage = function(e){
                alert(e.data)
            }
        }
    </script> -->



















</body>
</html>